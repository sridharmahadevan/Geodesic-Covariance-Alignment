function [vGraph, vEigenVecs, vEigenVals, vOpts, vLaplacian, vNNInfo, vDiffusion, vQ] = FastLaplacianDetEigs( cX, cOpts, cF, cGraph );%% function [vGraph, vEigenVecs, vEigenVals, vLaplacian, vNNInfo, vDiffusion] = FastLaplacianDetEigs( cX, cOpts, cF, cGraph );%% Computes the top eigenfunctions of a Laplacian on a graph induced by a set of points.% There are several options on how to build the graph given the set of points: in particular it is possible to use fast nearest neighbor searches% or fast range searches, and it is possible to have arbitrary distances in the computation of the weights of the graph.% It is possible to normalize and symmetrize (when necessary/desired) the Laplacian in several ways.% For most common usage, sparse computations are used and the algorithm has complexity almost n\log(n), where n is the number of points.% High dimensionality and/or high connectivity are the main factors that can slow the algorithm considerably, even to unfeasibility.%% IN:%   cX              : M by N matrix of M points in R^N%   cOpts:          : structure containing the following fields:%       [Type]           : 'nn','gauss', 'harmonic' or 'selftuning'. Default: 'gauss'%       if Type == 'nn':%                   [kNN]           : number of nearest neighbors if cType=='nn'. Default : 10.%                   [Delta]         : width of Gaussian weights. %                                       If Delta == Inf, then uses 1 for all edge weights. %                                       If Delta == 0, then uses location-depedent Gaussian width, %                                           comparable to the distance of the farther kNN-th nearest neighbor%                                       Default: Inf.%                   [WeightType]    : 'gauss' or 'harmonic'. Default: 'gauss'%       if Type == 'gauss' or 'harmonic'%                   [Delta]         : width of Gaussian if cType=='gauss'. Default: result of call to FastLaplacianEstimateGoodDelta.%                   [Precision]     : determines the range_search radius when cType=='gauss'. Default: 1e-3.%                   [Radius]        : determines the range_search radius when cType=='gauss'. If specified, it overrides Precision.%       if Type =='selftuning'%                   [kNN]           : number of nearest neighbors if cType=='nn'. Default : 10.%                   [kNNdelta]      : the kNNsigma-th nearest neighbor is used to set the scale delta. Default: 7.%                   [alpha]         : factor in front of the scaling \sigma. See self-tuning spectral clustering paper. Default: 1.%       [NormalizationType] :   'graph':   D^{-1/2}(D-W)D^{-1/2}%                               'graphmarkov' : D^{-1/2}(D-W)D^{-1/2} but the returned eigenvectors are rescaled by D^{-1/2}, so they are the same as 'ave'%                               'beltrami' : It's like 'graphmarkov' applied to the kernel obtained after initial density normalization by D^{-1}%                               'bimarkov' : Doubly-stochastic matrix%                               'ave':     D^{-1}(D-W)%                               'noave':   D-W%                               'none':    W%                               Default: 'graph'%       [kNNCoarse] : do kNNCoarse fast nearest neighbor with constraints on certain coordinates. Default: [].%       [NNCoordinates] : used only if kNNCoarse is specified, is the list of coordinates to which constrain a first kNNCoarse nn search.%       [UseFastNNSearch] : forces the use or not of fast nearest neighbor searches%       [Epsilon] : no diffusion outside any local metric ball of radius Epsilon (used only by flexible metrics)%       [WhichEigenVals] : 'small' or 'large'. Default: 'small'.%       [MaxEigenVals]   : Maximum number of eigenvalues to keep. Default : 10.%       [EigEnergyThres] : fraction of energy of the first MaxEigenValues to preserve, it's a number \in (0,1]%       [EigPrecision]   : precision in the computation of the eigenvalues and eigenvectors (as defined in the Matlab function eigs). Default: 1e-6.%       NNsymm  : how to symmetrize the weight matrix (empty otherwise)%                   'ave' for 1/2(W+W*)%                   'leftadj' for W*W%                   'rightadj' for WW*%       [NNsymm01] : Boolean: true means 0 or 1 weights after symmetrization. Default: false.%       [SparsifyW] : structure containing the following fields:%                       Type : 'absolute','relative','quantile'%                       Abs  : true or false depending on whether the size or distribution should be of the entries or of the absolute value of the entries of W%                       Value : a real number describing the upper bound on the entries of W, or the upper bound on the relative size of the entries of W, %                               or the percentage of entries of W to be kept%       [GetWeightsFcn] : pointer to function to compute weights, as in GetWeightsFcn_Template.m%       [GetWeightsFcnParam] : extra parameter to be passed to the GetWeightsFcn%       [EigenVecHint] : initial guess for the eigenvectors, used to initialize the eigensolver. TBD%   [cF]              : function whose gradient affects the weights%   [cGraph]          : structure like the vGraph returned value: if passed this is the graph to be used.%   [cVerbose]        : display progress messages or not. Default: 0.%% OUT:%   vGraph      : structure: vGraph.D are the degrees of cX,%                            vGraph.W is the weights distance matrix%   vEigenVecs : MaxEigenVals by M matrix of eigenvectors%   vEigenVals : MaxEigenVals column vector%   vOpts      : options actually used%   vLaplacian : sparse matrix representing the laplacian%   vNNInfo    : structure with nearest neighbor information%   vDiffusion : diffusion matrix%% USES:%   FastGraphFromData, FastLaplacianEigs%% SOURCE CONTROL%   MM : 03/13/04           [changed slightly interface, because of changes in FastGraphData (integrated with range searches)]%   MM : 05/31/04           [changed a few things in the parameters, to adjust for changes to FastGraphFromData]%   MM : 06/07/04           [small changes]%   MM : 02/13/05           [small changes]%   MM : 09/12/05           [small changes]%   MM : 10/04/05           [added self-tuning]%   MM : 5/2/06             [added bimarkov]%% Parameter checksif nargin < 2, cOpts = []; end;if nargin < 3, cF = []; end;if nargin < 4, cGraph = []; end;% Parameter: Maximum number of eigenvalues to keepif ~isempty(cX),    % Fix a problem with nn-search, which doesn't work if cX is 1-D (!)    if size(cX,2)==1,        cX = [cX,zeros(size(cX,1),1)];    end;        if ~isfield(cOpts,'MaxEigenVals'),        cOpts.MaxEigenVals = 20;    end;    lMaxEigs = min(cOpts.MaxEigenVals, size(cX,1));else    if ~isfield(cOpts,'MaxEigenVals'),        cOpts.MaxEigenVals = 10;    end  end;if ~isfield(cOpts,'Verbose'),    cOpts.Verbose = false;end;if ~isfield(cOpts,'Lanczos'),    cOpts.Lanczos = false;end;if ~isfield(cOpts,'EigPrecision'),    cOpts.EigPrecision = 1e-1;end;% Build the graphif cOpts.Verbose, fprintf('Constructing graph...\n'); end;if isempty(cGraph),    [vGraph,vNNInfo,vOpts] = FastGraphFromData(cX,cOpts,cF,cOpts.Verbose);else    vGraph=cGraph;    vNNInfo = [];    vOpts = cOpts;end;if cOpts.Verbose, fprintf('done.\n'); end;if (~isfield(cOpts,'NNsymm01')) | (isempty(cOpts.NNsymm01)),    cOpts.NNsymm01 = false;end;% Compute the eigenfunctions of the Laplacianif cOpts.Verbose, fprintf('Normalizing and computing the eigenfucntions...\n'); end;%[vEigenVecs, vEigenVals,vOpts,vLaplacian,vDiffusion] =%FastLaplacianEigs(vOpts, vGraph.D, vGraph.W, cOpts.MaxEigenVals, cOpts.EigPrecision,  cOpts.Verbose );% SRIDHAR: added Krylov subspace conditioning to make W tridiagonal 1/25/08% if cOpts.Lanczos==true%     fprintf('Lanczos pre-processing...\n'); %     [vW,vQ] = lanczos_red(vGraph.W, -1*ones(size(vGraph.W,1),1),cOpts.EigPrecision,cOpts.MaxEigenVals); % %     [vEigenVecs, vEigenVals,vOpts,vLaplacian,vDiffusion] = FastLaplacianEigs(vOpts, 3*ones(size(vW,1),1),...%         vW,cOpts.MaxEigenVals, cOpts.EigPrecision, cOpts.Verbose );%     %vLaplacian = vQ*vLaplacian*vQ'; %     vEigenVecs = (vQ*vEigenVecs')'; % else     [vEigenVecs, vEigenVals,vOpts,vLaplacian,vDiffusion] = FastLaplacianEigs(vOpts, vGraph.D,...        vGraph.W,cOpts.MaxEigenVals, cOpts.EigPrecision,  cOpts.Verbose );    vQ = [];%end; if isfield(cOpts,'EigEnergyThres')    if cOpts.EigEnergyThres < 1        % Keep enough eigenvectors to satisfy the specified threshold            lEnergyTotal = norm(vEigenVals);        lEnergySoFar = 0;        for lk = 1:lMaxEigs            lEnergySoFar = lEnergySoFar + (vEigenVals(lk)^2);            if lEnergySoFar/lEnergyTotal >= cOpts.EigEnergyThres                break;            end;        end;        % Return the results        vEigenVecs = vEigenVecs(:,1:lk);        vEigenVals = vEigenVals(1:lk);    end;end;if cOpts.Verbose, fprintf('done.\n'); end;return;