function [vEigenVectors,vEigenValues,vOpts,vLaplacian,vDiffusion] = FastLaplacianEigs( cOpts, cDegrees, cWeights, cNumberOfEigenValues, cPrecision, cVerbose )% function [vEigenVectors,vEigenValues,vLaplacian] = FastLaplacianEigs( cOpts, cDegrees, cWeights, cNumberOfEigenValues, cPrecision )%% IN:%   cOpts              : structure containing%       [NormalizationType] :'graph':   D^{-1/2}(D-W)D^{-1/2}%                            'graphmarkov' : D^{-1/2}(D-W)D^{-1/2} but the returned eigenvectors are rescaled by D^{-1/2}, so they are the same as 'ave'%                            'beltrami' : D^{-1}(D-W)D^{-1}%                            'ave':     D^{-1}(D-W)%                            'noave':   D-W%                            'none':    W%                            'combdir'  Phi - (Phi P + P* Phi)/2%                            Default : 'graph'.%       [WhichEigenVals] : 'small' or 'large'. Default = 'small'.%       [NoEigenVecs]    : if true, does not compute the eigenvectors. Defuault: false.%   cDegrees    : 1xN vector: d_{i}=order of the vertex i%   cWeights    : NxN matrix : w_{ij}=weight between vertex i and vertex j, a symmetric matrix.%   cPrecision  : Desired precision%% OUT:%   vEigenVectors, vEigenValues: eigenvectors and eigenvalues of the Laplacian.%   vLaplacian : the Laplacian sparse matrix%% USES:%%commented out markov normalization of eigenvectors, %(search for vEigenVectors(lk,:)/norm(vEigenVectors(lk,:) aug 22 2005 )%added possibility of no eigenfunction computation, aug 25vOpts = cOpts;% Default argumentsif ~isfield(cOpts,'NormalizationType'),    cOpts.NormalizationType = 'graph';end;if ~isfield(cOpts,'WhichEigenVals'),    cOpts.WhichEigenVals = 'small';end;if ~isfield(cOpts,'NoEigenVecs'),    cOpts.NoEigenVecs=0;end;if ( strcmpi(cOpts.NormalizationType,'graph')==1 ) | ( strcmpi(cOpts.NormalizationType,'graphmarkov')==1 )                  % D^{-1/2}(D-W)D^{-1/2}    DD = speye(length(cDegrees));    % Normalized Laplacian    for i=1:length(cDegrees)        if (cDegrees(i) ~= 0)            DD(i,i) = 1/sqrt(cDegrees(i));        else             DD(i,i) = 0;        end    end    % Normalized laplacian    vLaplacian = speye(size(cWeights,1))-DD*cWeights*DD;%DD*(spdiags(cDegrees,0,speye(size(cWeights,1)))-cWeights)*DD;    if nargout>4,        vDiffusion = DD.^2*cWeights;    end;    % Force simmetry of Laplacian to precision    [lI lJ lV] = find(vLaplacian);        lLaplacianT = sparse(lJ,lI,lV,size(vLaplacian,1),size(vLaplacian,2),length(lI));    vLaplacian = (vLaplacian + lLaplacianT);clear lLaplacianT;    vLaplacian = vLaplacian/2;elseif (strcmpi(cOpts.NormalizationType,'ave')==1)               % D^{-1}(D-W)    DD = speye(length(cDegrees));    % Normalized Laplacian    for i=1:length(cDegrees)        if (cDegrees(i) ~= 0)            DD(i,i) = 1/cDegrees(i);        else             DD(i,i) = 0;        end    end    % Laplacian just has zero mean    vLaplacian = speye(size(cWeights,1))-DD*cWeights;    [lI lJ lV] = find(vLaplacian);        lLaplacianT = sparse(lJ,lI,lV,size(vLaplacian,1),size(vLaplacian,2),length(lI));    vLaplacian = (vLaplacian + lLaplacianT);clear lLaplacianT;    vLaplacian = vLaplacian/2;    if nargout>4,        vDiffusion = DD*cWeights;    end;elseif strcmpi(cOpts.NormalizationType,'combdir')==1               % phi - (phi*P + P'*phi)/2    % do something for combdir    n = length(cDegrees);                        % number of data points    for i = 1:n        if (cDegrees(i) == 0)            P(i,:) = spalloc(1,n,n);        else            % OPTION 1 - Assume Uniform Probability of Moving to Neighbors            %      this is the safest assumption - not dependent on exact value of weights            numedges = sum(cWeights(i,:) > 0);            P(i,:) = (cWeights(i,:) > 0) / numedges;            % OPTION 2 - Assume Probability of Moving to Neighbors Depends on Weights%            P(i,:) = cWeights(i,:) / cDegrees(i);    % P is a sparse probability transition matrix, just as sparse as W        end    end    eta = 0.99;                                  % probability of not teleporting    tol = 1e-12;                                 % tolerance on L_{max} covergence of perron vector    perron = getPerronIter(P, eta, tol);         % invariant distribution over states    save jefftest perron;                        % save this in order to look at it later    % Initialize variables    dummy = fastDirCombMult(0, P, perron, eta);    vLaplacian = [];    vDiffusion = [];        % I don't know what this iselseif strcmpi(cOpts.NormalizationType,'kronmarkovtwo')==1    % form the transition matrix        fprintf('Kronecker Decomposing Random Walk Matrix ...\n');         [lI lJ lV] = find(cWeights);    for i=1:length(lI)        lV(i) = lV(i) / cDegrees(lI(i));    end    P = sparse(lI,lJ,lV,size(cWeights,1),size(cWeights,2),length(lI));    clear lI; clear lJ; clear lV;    % Permute the rows/cols of P%    permutationIdx = symrcm(cWeights);      % reverse Cuthill-McKee ordering%    permutationIdx = colamd(cWeights);      % column approximate minimum degree%    permutationIdx = symamd(cWeights);      % minimum degree permutation    % Permute the rows/cols of P according to METIS    numPartitions = size(P,1) / cOpts.BlockSize(1);    fprintf('\n');        metisDir    = '/Users/mahadeva/Documents/umass/code/rl-code/metis-4.0/';             % SRIDHAR, YOU MAY NEED    graphSubDir = '/Users/mahadeva/Documents/umass/code/rl-code/metis-4.0/Graphs/';                        % TO CHANGE THESE!!!!!!    rpiSubDir = '/Users/mahadeva/Documents/umass/code/RPI Feb 1 2008/rpi_kronecker/RPI';     fName       = [graphSubDir,'mygraph'];         % Delete old files    %    unix(['cd ', graphSubDir]); %    [ignore, ignore] = unix(['del ' graphSubDir fName '.graph']);%    [ignore, ignore] = unix(['del ' graphSubDir ' ' fName '.graph.' num2str(numPartitions)]);    % Create new files    createMetisGraphFile(fName, cWeights);        lCommandStr = [metisDir, 'kmetis ', ' ',  fName, '.graph ', ' ', num2str(numPartitions)];%    [ignore, ignore] = unix(['../kmetis ' fName '.graph '  num2str(numPartitions)]);    [ignore, ignore] = unix(lCommandStr);     partitions  = dlmread([fName '.graph.part.' num2str(numPartitions)]);    %    unix(['cd ', rpiSubDir]);     [ignore, permutationIdx] = sort(partitions);    P = P(permutationIdx, permutationIdx);    % Do the Kronecker Factorization    [kronInfo, vEigenValues, numLeafs] = recursiveKroneckerFactorization2(P, cOpts.BlockSize,...                                                            cNumberOfEigenValues, cOpts.OrderBtoC, 1, 1);    % Determine the inverse permutation indexing    [ignore, invPermutationIdx] = sort(permutationIdx,'ascend');    % Save the invPermutationIdx to be able to index into kronInfo later    kronInfo{numLeafs+1, 2} = invPermutationIdx;    % Specify other output variables    vEigenVectors = kronInfo;    vLaplacian = [];    vDiffusion = [];elseif strcmpi(cOpts.NormalizationType,'beltrami')==1                 % D^{-1}(D-W)D^{-1}    DD = speye(length(cDegrees));    % Normalized Laplacian    for i=1:length(cDegrees)        if (cDegrees(i) ~= 0)            DD(i,i) = 1/cDegrees(i);        else             DD(i,i) = 0;        end    end    % Normalized laplacian    lKtilde=DD*cWeights*DD;    % Compute D for the new density-normalized kernel.    lDegrees = sum(lKtilde,2);    % Normalized Beltrami Laplacian    for i=1:length(lDegrees)        if (lDegrees(i) ~= 0)            DD(i,i) = 1/sqrt(lDegrees(i));        else             DD(i,i) = 0;        end    end    vLaplacian = DD*(spdiags(lDegrees,0,speye(size(cWeights,1)))-lKtilde)*DD;    if nargout>4,        vDiffusion = DD.^2*lKtilde;                end;    % Force simmetry of Laplacian to precision    [lI lJ lV] = find(vLaplacian);    lLaplacianT = sparse(lJ,lI,lV,size(vLaplacian,1),size(vLaplacian,2),length(lI));    vLaplacian = (vLaplacian + lLaplacianT);clear lLaplacianT;    vLaplacian = vLaplacian/2;    clear lKtilde lDegrees;elseif strcmpi(cOpts.NormalizationType,'bimarkov')==1,    vDiffusion = Bimarkov(cWeights, struct('Quiet',true,'AbsError',cPrecision));                    vLaplacian = speye(size(cWeights,1))-vDiffusion;                    if nargout<=4,        clear vDiffusion;    end;elseif strcmpi(cOpts.NormalizationType,'noave')==1,           % D-W    % Normalized laplacian    vLaplacian = spdiags(cDegrees,0,speye(size(cWeights,1)))-cWeights;    if nargout>4,        vDiffusion = cWeights;    end;else                                                % W    vLaplacian = cWeights;    if nargout>4,        vDiffusion = []; % TODO    end;end;    if cOpts.NoEigenVecs~=1    % if kronmarkov, then we're already done    if (strcmpi(cOpts.NormalizationType,'kronmarkovtwo') == 1)        vOpts = cOpts;        return;    end    % Then we want to find eigenvalues and eigenvectors    opts.tol = cPrecision;%     opts.issym=1;                           % No matter what the Laplacian, it's always symmetric since we assume W symmetric     opts.disp = 0;     opts.isreal = 1;%    if cNumberOfEigenValues>=size(vLaplacian,1),%        cNumberOfEigenValues = size(vLaplacian,1)-2;%    end;    if (cNumberOfEigenValues >= length(cDegrees))        cNumberOfEigenValues = length(cDegrees) - 2;    end;    if (strcmpi(cOpts.NormalizationType,'combdir')==1)        opts.tol = 1e-12;        [vEigenVectors, vEigenValues] = eigs(@fastDirCombMult, n, cNumberOfEigenValues, 'sa', opts);        vEigenValues = diag(vEigenValues);    else        if strcmpi(cOpts.WhichEigenVals,'small')==1            [vEigenVectors, vEigenValues]=eigs(speye(size(cWeights,1))-vLaplacian,cNumberOfEigenValues,'la',opts);            vEigenValues = 1-diag(vEigenValues);        else            [vEigenVectors, vEigenValues]=eigs(vLaplacian,cNumberOfEigenValues,'la',opts);            vEigenValues = diag(vEigenValues);        end;    end;    vEigenVectors = vEigenVectors';    % Sort the eigenvalues from small to big, do the same on the eigenvectors    [lTemp lIdx] = sort(vEigenValues);    vEigenVectors = vEigenVectors(lIdx,:);    vEigenValues = vEigenValues(lIdx);    if (strcmpi(cOpts.NormalizationType,'graphmarkov')==1) | (strcmpi(cOpts.NormalizationType,'beltrami')==1)         for lk = 1:size(vEigenVectors,1)             vEigenVectors(lk,:) = vEigenVectors(lk,:)*DD;             vEigenVectors(lk,:) = vEigenVectors(lk,:)/norm(vEigenVectors(lk,:));         end;    end;else    vEigenVectors=[];     vEigenValues=[];endvOpts = cOpts;return;